= ファイルの読み書き

ファイルの読み書きについての基本事項について解説します．
ここでは Linux OS のシステムコールを使って説明しますが，
各言語で使えるファイル操作ライブラリなどは全部これらのラッパーと思ってもらって良いです．
流れについては説明しますが，具体的なシステムコールの使い方(引数をどうするかなど)の
詳細については man を見てください．
コマンドラインで `man 2 open` などと実行すると，システムコール `open()` の manual を読めます．
数字の意味は `man man` を参照のこと．

ファイル操作の方法は主に二種類存在します．
read/write を使う方法と mmap を使う方法です．



== 基本的なシステムコール

=== 共通: `open()`, `close()`

ファイルを open したり close したりします．open してないファイルは読み書きや mmap できません．
Open されているファイルはファイルディスクリプタ (通称 fd) で管理します．


=== 読み書き: `read()`, `write()`, `lseek()`

その名の通り，ファイル上でデータを読み書きします．ファイルによって抽象化されていますので，
任意の size (byte 単位) のデータを読み書きできます．
ファイルの位置を指定するシステムコールが `lseek()` として分離されているので注意が必要です．
`lseek()` と `read()`/`write()` が合体したものと見做せる `pread()`/`pwrite()` もあります．
その他，`readv()`, `writev()`, `preadv()`, `pwritev()` などがあります．


=== 永続化: `fsync()`, `fdatasync()`

永続化を行うシステムコールです．
これを読んで正常終了しない限り，書き込んだデータが永続化されている保証はありません．
逆に，`fsync()`/`fdatasync()` を呼ばなくても，永続化されている可能性はもちろんありますので，注意してください．


=== mmap

`mmap()` システムコールは，open されているファイルの一部(または全部)連続領域を
プロセスメモリ空間にマッピングします．`munmap()` はマッピングを開放します．
mmap されたファイルは，メモリの読み書きをするとファイルの読み書きができます．
内部的に page cache をうまく使ってくれますが，細かい制御は難しいです．
`msync()` システムコールは，変更の永続化を強制します．
mmap はファイルのデータ空間をメモリにマップする機能以外に，
メモリを確保する用途 (`malloc()` と同様，ただし，内部的な動作は多少違います) でも使えます．
特に huge page を確保するために使われます．


=== read/write と mmap，どちらをどう使うか

単に新しくファイルを open して，先頭から順に書いて，close するのであれば，
mmap ではなく `write()` を使うと良いでしょう．
Read-only (それ以上変更しないことに決めた) ファイル上で検索などの複雑な読み込み操作をするときは，
mmap によるメモリアクセスを使えばコードが単純になると思います．
(それでも参照データをポインタに変換するなどの手間は必要ですが．．．)
mmap を使う場合，変更されたデータの永続化を `msync()` を呼ぶことで保証することができますが，
逆に永続化されていないことを保証する仕組みが備わっていないことに注意してください．
(要はメモリに書いてしまったら裏で勝手に永続化しようとしてしまうということ．)
`write()` を使う場合は，バッファの書き換えと `write()` の呼び出し操作が分離されていますから，
ファイルへの反映タイミングをある程度制御できます．



== 以下は，参考までに

=== 非同期 IO

Linux では aio という非同期 IO が使えます．
同期 IO は対応する read/write システムコールが完了したら IO も完了していますが，
非同期 IO では IO の submit と completion 待ちが別の API として分かれています．
`open()` した後，aio 専用のシステムコール(そのラッパー)を呼ぶことに変わりはありませんが，
`open()` の flags 引数に `DIRECT_IO` をつけること，
使うバッファが block size に alignment されていることなどが要求されます．
興味がある人は libaio というライブラリをインストールして使ってみてください．
Linux においては posix aio (`struct aiocb` を使う)というものもありますが，
libaio (`io_context_t` を使う)の方が良いと思います．


=== Hole

Linux ファイルシステムの比較的新しい機能として hole があります．
文字通り，ファイルに穴 (hole) を空けます．
hole は zero データが入っているように見えますが，ファイルのデータブロックとしての実体は確保されていません．
hole には使用領域を節約できる，アクセスを高速化できる，という効果があります．
`fallocate()` を使って穴を空けます(punch hole)．
最小 size や alignment の制約が強いので注意してください．
必要な場合，`lseek()` の `whence` 引数に ``SEEK_DATA` か `SEEK_HOLE` を指定して hole を検知します．
ファイルシステムがサポートしている場合は使えます．

=== その他 API

`ftruncate()` は，ファイルサイズを変更します．
`flock()` はファイルを排他します．同様の用途で `lockf()` や `fcntl()` もありますが，微妙に違います．

=== メタデータ/ディレクトリの操作

ファイルのメタデータやディレクトリの操作は，別のシステムコール/関数群
があります．

`fstat()`, `stat()`, `lstat()`
`chmod()`, `chown()`
`link()`, `symlink()`, `unlink()`, `rename()`
`mkdir()`, `rmdir()`
`opendir()`, `closedir()`, `readdir()`, `scandir()` (これらはシステムコールというより glibc 関数)
