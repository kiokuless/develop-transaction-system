= ログ先行書き込み


英語だと Write-ahead Logging (WAL，ワル) と言います．
その名の通り，log を (data より) 先に書くということです．


== そもそも log って何でしょうか？

log はトランザクションによるデータの変更後もしくは変更前の(差分)データのことです．
(ごく稀に，read log，すなわちトランザクションが何を読んだかという log，
を考えることがありますが，非効率すぎて現実的ではありません．)
変更後のデータを redo log，変更前のデータを undo log といいます．
通常，log はデータベース本体のデータとは別に記録されます．


== 何のために log はあるの？


redo log はその名の通り，redo するための log，トランザクションをあったことにするためのものです．
undo log は undo するための log，トランザクションをなかったことにするためのものです．
トランザクションが複数の操作からなり，それらの操作を crash がある世界で atomic に実行したのと同じ結果を得るためです．
Crash が発生したときは，データベース本体のファイルはどう頑張っても中途半端な状態になってしまいます．
それは，atomic にしたい複数操作が実際には atomic に実行できないからです．
log があれば，crash 直後のデータベース本体ファイルが中途半端な状態から，
全てのトランザクションについて，あった/なかったのどちらかの状態に回復できます．
Commit できたとアプリケーションに返事済みのトランザクションは，必ずあったことにしないといけません．


== 何故「先行」する必要があるの？

トランザクションを後からあったことにする/なかったことにすることが出来る方法であればどんな方法を採用しても良いのですが，
「先行」して書く方法が 1991 年の ARIES 論文が発表された前後から主流となっています．
(NVRAM の台頭で変わるかも．．．)
先行して log を書いておけば，いつ crash が発生したとしても，
データベース本体の中途半端な状態から回復するために必要な log が
永続化されている状態を保つことが可能です．
WAL ファイルに追記していけば良いことから
シーケンシャルアクセスがランダムアクセスよりも高速であり，永続化にも追加の操作(fsync 相当)を必要とする
HDD とは相性が良いと思われます．
並列に WAL を書く方法も最近は(少なくとも研究レベルでは)当たり前になりました．
(並列じゃない WAL をシングル WAL，並列のものを パラレル WAL と区別して呼ぶことにします．)
似たような方法として，ファイルシステムのジャーナルも WAL の考え方を採用しています．
例えば Linux OS で広く使われている ext4 ファイルシステムは，
メタデータ操作を atomic 実行の対象として，crash しても fsck (という名の全メタデータチェックツール)
の実行が不要な(crash recovery 相当のジャーナルリプレイ操作のみ必要)システムを採用しています．




== Redo/undo log は両方必要？

データベース本体ファイルへの変更の反映についての制約を一番緩いものにしたければ両方必要です．
あるトランザクションの時系列による状態の変化に注目して考えてみましょう．

 1. トランザクション開始から commit/abort 命令発行直前まで
 2. commit/abort 処理の実行中
 3. commit/abort 処理完了後

ここでは，話を簡単にするため redo log，undo log，commit/abort log しかないものとしましょう．
commit/abort log は log の中で最後に書きます．
commit log が永続化されていないトランザクションは abort 扱い(なかったこと)になります．
ひとつひとつの log の適用 (redo もしくは undo 操作のこと)は atomic に実行できるものとします．
(実際は atomic に操作できなかったりするので，double write するなどの工夫が必要です．)
また，同じ log を複数回適用しても結果は変わらないものとします(べき等性)．
それぞれの log を適用する順序には制約があることには意識しておいてください．

=== Redo log しか書かない (undo log がない) システム

Undo log がないということは undo できないので，一部でもデータベース本体に変更を反映したトランザクションは，
必ずあったことにしないとけません．
ということは，少なくとも (1) の間にデータべース本体のファイルに変更を反映できないという制約が発生します．
さらに，commit が確定する(当該トランザクションの log が全て永続化する，
かつ，それが依存している全てのトランザクションの commit が完了している)まで，
データベース本体に変更を反映できないという制約も発生します．
つまり，(3) になって始めてデータベース本体のファイルに変更を反映しても良いことになります．
(あくまでディスク上のファイルについての話であって，メインメモリ上では通常もっと前に反映されています．)
すなわち，commit log の永続化が終わってからデータベース本体に反映を開始することになります．

=== Undo log しか書かない (redo log がない) システム

Redo log がないということは redo できないので，データベース本体に変更を反映するまで commit したことにできません．
undo はできるので，(1) の間でも undo log が永続化済みの操作は，どんどんデータベース本体に反映して問題ありません．
(2) において，commit が確定するためには，当該トランザクションの log が全て永続化する，かつ，データベース本体への反映が永続化も含めて終わっている，かつ，依存しているトランザクションが commit 完了している，必要があります．
つまり，commit log はデータベース本体の永続化が完了してから書くことになります．
(3) の時点でそのトランザクションについてやるとは全て終わっている状態です．


=== Redo log と undo log の両方がある場合

片方しかない場合に比べて制約が大幅に減ります．
必要な制約は，redo/undo log を永続化してから対応する操作をデータベース本体ファイルに反映開始することのみ．
commit に必要な条件は，commit log まで永続化が完了する，かつ，依存しているトランザクションが commit 完了していることです．



図にするとより分かりやすいと思いますが，自分で書いてみてください(ぉぃ)



== Crash recovery

Crash が発生した直後のデータベース本体ファイルは中途半端な状態になっています．
これを log を使ってあった/なかったのどちらかに確定させていきます．
まず，log を先頭からなめて，トランザクション毎にあった/なかったのどちらに倒すか決定します．
あるトランザクションを「あった」ことにする条件は，

 1. トランザクションの commit log が記録されている
 2. トランザクションが依存していた全てのトランザクションが commit となっている

なのですが，並行実行制御にある制約を入れると (1) が満たされると (2) も自動的に満たされるようになるので，
ここでは (1) のみを気にすることにします．これなら簡単ですよね．
(2) をきちんと考え始めると，結構込み入った話になります．「依存」とはなにかということです．
ここでは話を簡単にするため，
トランザクション A が読み書きしたデータをその後でトランザクション B が読み書きした場合，
B は A に依存している，くらいに考えてください．
ただし，片方は write であるケースのみ依存とし，A も B も読んだだけなら，それらは依存とは見做さないとします．
つまり，w-r, w-w, r-w の 3 つの関係のみ依存と考え，r-r は依存と考えません．
前者 3 つには flow-dependency, output-depnedency, anti-dependency という名前が付いています．

次に，あったことにするトランザクションを redo します． (redo log がないシステムでは不要です)
最後に，なかったことにするトランザクションを undo します． (undo log がないシステムでは不要です)
Log 適用の順番には気をつける必要があります．
シングル WAL であれば，最も単純な方法として，log の書かれた順番を守って適用すればまず問題ありません．
実際は，トランザクションの依存関係(一般には半順序関係です)を満たすように
適用順序を制御すれば良いのですが，
WAL ファイルに書かれた時点で，順序関係の情報が一部しか残っていないことも多いです．
(このあたりは並行実行制御の方法とも絡んできます．)
半順序関係を満たせば良いということは，頑張れば，ある程度並列に適用することも可能です．


== Checkpointing

log はいつまで残しておけば良いでしょうか？
それは，log に対応するトランザクションが完了していて，
当該トランザクションの全ての log の操作がデータベース本体ファイルに反映され終わるまでです．
それらの条件が満たされた log はもう不要なので，消すことができます．
メインメモリが大量にあったり，そもそもインメモリデータベースなどでは，
データベース本体ファイルへの変更の反映がずっとずっと先延ばしにすることが可能です．
先延ばしし続けると crash 時に適用しなければならない log が多くなりすぎて，crash recovery にかかる時間が
長くなってしまうだけでなく，いつまでも log を消せないということになります．
それを防ぐために行う操作が checkpointing で，つまり，
先延ばししているデータベース本体ファイルへの反映を実行して，log を消す作業です．
プロトタイプでは後回しになる機能ですが，長時間 DBMS を動かし続けるためには必須の機能と言えます．
