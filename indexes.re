= インデクス構造

インデクス構造は，ひとことで言うと，
ある table において key を指定して record を絞り込む操作を高速に実行するための補助的なデータ構造です．

インデクスがなくても，table の全 records をチェックすれば，絞り込み操作は実現できますが，
例えば，1M個 (M は million，100万の意味) の records が存在する table の中で，たった 1 行を見付け出すために
1M 個を全部読んで調べるというのはいかにも効率が悪いですね．

インデクス構造は tree または hash table またはその他のデータ構造で出来ています．
N 個の records から成る table を検索するために必要なデータアクセスが，
log N 回くらいで済んだり，定数回くらいで済んだりするようなデータ構造です．
しっかりと考える場合は最悪のケースも検討しなければなりませんが，
今はそれをあまり考えずに，これらのアクセス回数の目安を O(log N)，O(1) と書いて表現します．
詳しく知りたい人は，"計算量" や "O記法" などのキーワードで調べてみてください．


== Tree 構造によるインデクスについて

 * 何らかの tree 構造を使います．
 * 構造は，色々なアルゴリズムの本やらインターネットやらに絵が載ってますので，調べてみてください．
 * メインメモリとディスク上の細かいデータのやりとりを頻繁に行う必要のある DBMS では，
   ページと呼ばれる(4KiB や 16KiB などの)固定サイズ連続領域を単位とした
   B+tree もしくはその亜種が良く使われています．
 * 昨今研究開発が盛んなインメモリデータベースでは，必ずしもディスク上の構造と
   メモリ上の構造が一致する必要はないため，
   メモリ上の表現は，必ずしもページ単位ではないものもあるようです．
 * root node から leaf node に key を比較しながら階層を降りていくと，求める key data を持つ
   record もしくは record への参照データの格納場所に到達します．
 * バランスしている tree 構造であれば，N 個の records からなる table に対してその index 構造は，
   (key が unique もしくはそれに近い場合) log N 段くらいの階層が存在するので
   計算量が O(log N) 程度となります．log の底は fanout によります．
 * バランスしている tree 構造といえば，B+tree の他に，red-black tree や AVL tree などが挙げられます．


== Hash table 構造によるインデクスについて

 * 配列がひとつ(場合によっては複数)あり，各アイテムがそれぞれリスト構造に繋っている構造です．
   (リストを使わないで複数の hash 関数を使うなどして空き領域を探すものもあります)
 * ある key data を元に record もしくは record 実体への参照データの格納場所に，
   O(1) で到達できます．
 * 具体的には，key を特定の hash 関数に通して，配列のインデクスを求めます．
 * 配列内の当該アイテムからはリスト構造に繋っており，
   リスト内の各ノードには record もしくは record 実体への参照データが格納されています．
 * Hash 関数の計算は，record 数に依存しませんので，計算量が O(1) となります．
 * 一般に，key data が異なっても hash 関数に通した結果が一致することはあるので，
   同一の hash 値を持つ records はそのリスト内に(一般には)挿入順などで格納されます．
   リストが table 内の record 数 N に対して無視できないくらいに長くなると，
   もはや O(1) でアクセスできるとは言い難くなります．
 * また，適切ではない hash 関数を使ってしまうと，配列のアイテム毎に偏りが出てしまい，
   key によって必要となるアクセス数のばらつきが大きくなり，やはり O(1) と呼びづらくなってきます．



原則として，ひとつの key 型につき，ひとつもしくは(性質の異なる複数の)インデクスを作ることがあります．
必ずしも，key があるからと言って，インデクスを作らなければならないということはありません．

インデクスは特定の絞り込み操作を高速化しますが，その代償として，
record をひとつ操作する度に，インデクスを全て更新する必要が生まれ，
record の更新コストが増えるというデメリットも受けいれる必要があります．
Column が多い record 型は key 候補も大量にあり，
考え得る key 候補の数だけインデクスを作ることはあまり現実的ではありません．

複数の条件で絞り込む場合，必ずしも全ての条件に一致するインデクスが必要というわけではなく，
部分的に絞り込んであとはマッチするかチェックするという方法も有効です．
重要なのは，最初にどれだけ絞り込めるかです (選択率が低い，とも言います)．

SQL を実行する場合は，どのインデクスをどう使うかなどもほぼ全部オプティマイザが頑張って決定しますが，
基本的な DBMS では，どのインデクスを使って絞り込むかなどをトランザクションロジック側で指定することが多いです．


== Index 構造の排他

シングルスレッドのプログラムであれば，インデクス構造を触っているのは自分ひとりなので，
排他について何も考える必要がありません．
もし，マルチスレッド/マルチプロセスなどで，複数の worker が同一のインデクス構造を触るときは，
排他の仕組みが必要となります．
どう排他すべきかについては，また別途考える機会があるかも知れません．
本稿ではこれ以上踏み込みません．




== Table 本体の構造は？

 * 2 パターン考えられます．
 * 1 つ目は，table 本体も index 構造になっている場合．
   この場合は primary key もしくは人工的な(隠し)key が定義されていて，それを使って
   record 本体の格納場所まで辿りつけるようになっています．
 * 2 つ目は，table 本体は別のデータ構造になっている場合．
   table 本体は full scan さえ出来れば良いので，例えば，
   insert された record や update の更新データは追記するようになっており，
   delete された record は，フラグなどで判別できるようにしておくなど．




===[column] メモ



> ・DBにどうして他のバランス木が使われないのでしょうか？インデックスとデータの関係の構造が作りにくいまたは管理しにくいのでしょうか？

B+tree は tree node が固定サイズの page (block) であるため、ディスク上とメモリ上のデータ表現に同じものを使えるというメリットがあります。
ディスクは block 単位のアクセスしかできないため (ファイルシステムによる抽象化によって任意サイズの IO が出来るように見えていますが、、、)、
tree node のサイズが小さかったり、可変長だったりすると、ディスクにとっては都合が悪いのです。
(ファイルシステム上のファイルを使うことを前提にすれば、出来なくはありません。非効率なことが多いですけれど。
HDD や flash SSD では block 単位の方が良いと思いますが、昨今実用化されつつある NVRAM であれば、
byte-addressable すなわち任意のサイズでの IO が出来るものがあるため、そのような制約は過去のものになる可能性はあります。)


> ・以前RDBMSのデータは直接ポインタは持たないとおっしゃっていたのですが、今回Recordへの参照データがノードとして存在しているとおっしゃられていました。これの違いがよくわからないので教えて頂きたいです。

内部的にはもちろん参照データを持っています。それは、インデクスのデータから record の実体の位置を指していたりするわけです。
もちろんデータ構造をどう設計するかに依存しますが、参照データなしでインデクス構造は作れないといっても過言ではありません。
SQL の世界(や、組込み DBMS のアプリケーションに見えるインターフェース) では、ポインタ(参照)を扱えません。
ユーザーにとって使えるポインタ型、参照型が(意図的に)用意されていないといった方が正確かも。




ハードウェアの進化によって、効率の良いソフトウェアのアーキテクチャはときどきガラリと変わります。
昨今だと、
 *  CPU の メニーコア化 (とにかく並列に動かさないと性能が出ない時代の到来)
 * メインメモリサイズの増大 (データベースがすっぽり収まるケースが増えてきた)
 * HDD から Flash memory へ (シーケンシャルアクセスとランダムアクセスの性能差が縮まる、flush request の有無)
 * 高速ネットワークの低価格化(Ethernet 10G とか)
 * GPGPU や FPGA の進化 (トランザクション処理にとっては今のところ影響は少ないが、分析系の処理には大きな影響がある)
 * NVRAM (3D Xpoint が去年発売にこぎつけましたが、それがメモリ階層の中で不可欠な役割を担うようになるかまだ五分五分と私は見ています)

が、大きな影響を与えていると思います。

トランザクション処理という視点で見ると、今の DBMS 研究の世界で見えているもの(私はかじっているだけですが。。)と、現実の DBMS 実装には大きな乖離があります。
今の主流の実装は、1990年代に最適だったものから継ぎ足しで進化してきているものが多いと思います。
商用の SQL をサポートするようなコードベースが大きい DBMS (Oracle とか MS SQL とか IBM DB2 とか) は、この変化についていくのが大変です。
それまで儲けたお金で莫大な投資をしなければ、ついていけません。
MySQL、PostgreSQL などは、どこまで付いていけるか、見物ですね。場合によっては新たに出てくる OSS に取って代わられる可能性もあります。
それでも、DBMS は最も「枯れている」ことを要求されるソフトウェアのひとつなので、一旦市民権を確立したソフトウェアの寿命は相対的に長いと思います。

===[/column]
