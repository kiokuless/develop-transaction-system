= インデクス

インデクス(index, 索引)は，ひとことで言うと，
ある table において key を指定して record を絞り込む操作を高速に実行するための補助的なデータ構造です．

インデクスがなくても，table の全 records をチェックすれば，絞り込み操作は実現できます．
これを table の full scan と呼びます．
例えば，1M 個 (M は million，100万の意味) の records が存在する table の中で，たった 1 行を見付け出すために
1M 個の records を全部読んで調べるというのはいかにも効率が悪いですね．

典型的なインデクスは tree map または hash table を使って構成されています．
これらは N 個の records から成る table を検索するために必要なデータアクセスが，
log N 回程度で済んだり，定数回程度で済んだりするようなデータ構造です．
しっかりと考える場合は最悪のケースも検討しなければなりませんが，
今はそれをあまり考えずに，これらのアクセス回数の目安を O(log N)，O(1) と書いて表現します．
詳しく知りたい人は，「計算量」や「O記法」などのキーワードで調べてみてください．
アルゴリズムとデータ構造の教科書には必ず載っているはずです．


== Tree map によるインデクスについて

Tree map を実現するには directed rooted tree (根付き有向木) 構造を使います．
Directed rooted tree は directed graph (有向グラフ) に制約を加えたものです．
Directed graph を表現するためには vertex (頂点) の集合 @<m>{V} と edge (辺) の集合 @<m>{E \subset V \times V} を用います．
@<m>{e=(v_1, v_2) \in E} について，
@<m>{v_1}から見て@<m>{e}を outcoming edge，
@<m>{v_2}から見て@<m>{e}を incoming edge と呼びます．
また，@<m>{e} から見て @<m>{v_1} を source，@<m>{v_2} を destination と呼びます．
Directed rooted tree とは，
(1) 連結 (connected) しており，
(2) incoming edge が存在しない root (根) と呼ばれる vertex がひとつだけ存在し，
(3) root 以外の vertex は全て incoming edge が唯ひとつのみ存在する，
これらの条件を全て満たす directed graph です．
Outcoming edge の存在しない vertex を leaves (葉) と呼びます．
各 vertex にとって，自身の outcoming edge で直接繋がっている vertex を children と呼び，
incoming edge で直接繋がっている vertex を parent と呼びます．
Directed rooted tree を考えるときは vertex のことを node と呼びますので
ここでもそれに倣います．

実際にメモリ上で tree map を作るとき，典型的には node を構造体として作ります．
Children や parent を参照するのにはポインタを使います．
(Parent へのポインタはなくても良いですが，効率的なアクセスのため用意することが多いです．
その代わり，冗長な情報を持つことになるので操作時に気を使う必要が出ます．)

Tree map は key を表す型が全順序を持つことを要求します．
Tree map を directed rooted tree で実現するとき，
各 node は自分の担当する key の連続部分空間を children の数だけ連続部分空間に分割して保持します．
ここでの連続部分空間とは，ひとつの範囲で表現できる部分空間，という意味で使っています．
つまり，ある key 値を持つ record が存在するならば，root node から
key 値が含まれる連続部分空間を持つ child を選ぶという操作を繰り返すことで
到達した leaf node が保持していることが保証されます．
つまり，木の深さ分だけ child を辿れば良いわけです．
木の深さは木がバランスしている(一番深い leaf node と浅い leaf node の深さの差が高々定数倍と見做せる)とき，
node 数 N に対して深さが O(log N) と見做せ，
O(log N) のステップ数で record に辿りつけます．


二分木(fanout すなわち children の数，が高々 2 の木構造)による
key の型が整数である tree map の例を示します:


//list[tree_map_example][]{
Root:
  key: 5
  children: N11, N12

N11:
  key: 3
  children: N21, N22

N12:
  key: 8
  children: N23, N24

N21:
  key: 1
  records: (1, 'aaa')

N22:
  key: 3, 4
  records: (3, 'ccc'), (4, 'ddd')

N23:
  key: 6
  records: (6, 'fff')

N24:
  key: 8, 10
  records: (8, 'hhh'), (10, 'jjj')
//}


Root node には key 値 5 が格納されています．これは，left child を辿っていった先には key < 5 の
record しか存在しないことを意味します．
同様に，right child を辿っていった先は 5 <= key の record しか存在しないことを意味します．
N12 は key < 5 の連続領域を担当しています．そして，さらに key < 3 と 3 <= key < 5 の 2 つの領域に分割し，
それぞれ children である N21, 22 に割り当てます．N22 は 5 <= key の領域を担当し，
5 <= key < 8 および 8 <= key の 2 領域をそれぞれ children である N23 および N24 に割り当てます．
N21, N22, N23, N24 は leaf node なので，その中に children へのポインタではなく，
対応する key 値を持つ record (もしくは record へのポインタ等)が格納されています．
この例では @<m>{N = 7}，@<m>{\log_{2\} N \approx 2.8} で，深さは 3 となります．

Tree map が有効に機能するためには木がバランスしていることが必要となります．
これを実現する操作方法を持つ木構造をバランス木と呼びます．
二分木だと，赤黒木(red-black tree) や AVL-tree が例として挙げられます．
また，大前提として fanout は 2 以上であることが必要となります．
Fanout が 1 だと，root を先頭とする連結リスト構造を意味しますので，我々が欲しい性質を持っていません．

メインメモリとディスク@<fn>{footnote_disk}上の細かいデータのやりとりを頻繁に行う必要のある DBMS では，
ページと呼ばれる(4KiB や 16KiB などの)固定サイズ連続領域を node として扱う
B+tree もしくはその亜種が良く使われています．具体的には扱うデータの量が
メインメモリよりも大きいことが想定される DBMS です．
これは fanout が 2 よりも大きいことがほとんどです．
一般に，non-leaf node は fanout - 1 個の key を格納する必要があるので，
B+tree の fanout は key のサイズに依存します．

//footnote[footnote_disk][HDD や SSD などの不揮発性を持つ二次記憶装置のことを通称としてディスクと呼びます．Hard Disk Drive の Disk です．]

昨今研究開発が盛んなインメモリデータベースは，データが全てメインメモリに納まる前提を置きますが，
必ずしもディスク上の構造とメモリ上の構造が一致する必要はないため，
メモリ上の tree map の表現は，必ずしもページ単位ではありません．

C++ を使っていてとりあえず tree map が欲しいときは，
@<tt>{std::map<Key, Value>} 型のオブジェクトを作ればそれでおしまいです．
もちろん thread-safe ではないですが．．．



== Hash table によるインデクスについて


@<m>{N} を自然数とし，key 空間から @<m>{\\{0, 1, ..., N-1\\\}} への写像 @<m>{h} を考えます．
Key 値を入力として適当な非負整数を出力する副作用のない関数を用意し，
出力された非負整数を @<m>{N} で割って剰余をとれば @<m>{h} は実現できます．

予め @<m>{N} 個のバケットと呼ばれる要素からなる配列を用意しておき，
key 値から @<m>{h} で得た値を配列のインデクスとして特定のバケットにアクセスします．
バケットには，複数の record が格納できるようになっており，
バケット内の key が一致する record を探すことで絞り込みます．
一例としてバケット内の records が連結リストでアクセスできるようになっている構造が挙げられます．
同一の key 値を持つ record は他のバケットには存在しないことが保証されており，
このバケットのみを探すだけで済みます．

以上が典型的な hash table の設計です．たくさんの亜種があります．
写像 @<m>{h} は hash 関数と呼ばれており，
このデータ構造が hash table と呼ばれている理由となっていると思います．

Hash 関数は key サイズに依存する計算量を必要とすることがほとんどですが，
Key サイズは record 数を M としたとき，M に対して定数と見做せることがほとんどです．
つまり key 値からバケットを特定する計算量は O(1) となります．

Hash table が有効に機能するためには，
各バケットに格納されている record 数が高々定数と見做せることが求められます．
このとき，key 値から record に到達するための計算量が O(1) と見做せるからです．
そのため，@<m>{h} は典型的に使われる key 空間の部分集合に対して一部のバケットに偏らないような
値を出力することが求められます．
また，ここで説明した hash table はバケット数 @<m>{N} が固定であるため，
@<m>{N} に対して record 数 @<m>{M} が小さすぎれば空のバケットが多くなって空間が無駄になるし，
逆に多すぎれば，バケット内の record 数が増えすぎて定数と見做せなくなってしまいます．
このような状況に対応するため，@<m>{N} 個の要素を持つ配列から
(通常は @<m>{N < N'} であるような) @<m>{N'} 個の要素を持つ配列にデータを移動することを rehash と呼びます．
Rehash が頻繁に発生する状況はもちろん hash table が有効に機能しているとは言い難いです．


さて，ごく単純な hash table の例を示します．Key 型は uint とし，@<m>{h} は簡単のためただの剰余としました:

//list[hash_table_example][]{
h(key: uint) -> {0,1,2,3,4}:
  return key % 5

Array as a hash table with size 5:
  [B0,B1,B2,B3,B4]


B0: (10, 'jjj')
B1: (1, 'aaa'), (6, 'fff')
B2: (7, 'ggg'), (12, 'lll')
B3:
B4: (9, 'iii')
//}

@<m>{N = 5} の hash table です．ただの剰余なので，5 で割った余りがそのままバケットインデクスを
示しています．


C++ を使っていてとりあえず hash table が欲しいときは，
@<tt>{std::unordered_map<Key, Value>} 型のオブジェクトを作ればそれでおしまいです．
やはり thread-safe ではありませんが．．．




== プライマリインデクスとセカンダリインデクス


QQQQQ









原則として，ひとつの key 型につき，ひとつもしくは(性質の異なる複数の)インデクスを作ることがあります．
必ずしも，key があるからと言って，インデクスを作らなければならないということはありません．

インデクスは特定の絞り込み操作を高速化しますが，その代償として，
record をひとつ操作する度に，インデクスを全て更新する必要が生まれ，
record の更新コストが増えるというデメリットも受けいれる必要があります．
Column が多い record 型は key 候補も大量にあり，
考え得る key 候補の数だけインデクスを作ることはあまり現実的ではありません．

複数の条件で絞り込む場合，必ずしも全ての条件に一致するインデクスが必要というわけではなく，
部分的に絞り込んであとはマッチするかチェックするという方法も有効です．
重要なのは，最初にどれだけ絞り込めるかです (選択率が低い，とも言います)．

SQL を実行する場合は，どのインデクスをどう使うかなどもほぼ全部オプティマイザが頑張って決定しますが，
基本的な DBMS では，どのインデクスを使って絞り込むかなどをトランザクションロジック側で指定することが多いです．


== Index 構造の排他

シングルスレッドのプログラムであれば，インデクス構造を触っているのは自分ひとりなので，
排他について何も考える必要がありません．
もし，マルチスレッド/マルチプロセスなどで，複数の worker が同一のインデクス構造を触るときは，
排他の仕組みが必要となります．
どう排他すべきかについては，また別途考える機会があるかも知れません．
本稿ではこれ以上踏み込みません．




== Table 本体の構造は？

 * 2 パターン考えられます．
 * 1 つ目は，table 本体も index 構造になっている場合．
   この場合は primary key もしくは人工的な(隠し)key が定義されていて，それを使って
   record 本体の格納場所まで辿りつけるようになっています．
 * 2 つ目は，table 本体は別のデータ構造になっている場合．
   table 本体は full scan さえ出来れば良いので，例えば，
   insert された record や update の更新データは追記するようになっており，
   delete された record は，フラグなどで判別できるようにしておくなど．




===[column] メモ



> ・DBにどうして他のバランス木が使われないのでしょうか？インデックスとデータの関係の構造が作りにくいまたは管理しにくいのでしょうか？

B+tree は tree node が固定サイズの page (block) であるため、ディスク上とメモリ上のデータ表現に同じものを使えるというメリットがあります。
ディスクは block 単位のアクセスしかできないため (ファイルシステムによる抽象化によって任意サイズの IO が出来るように見えていますが、、、)、
tree node のサイズが小さかったり、可変長だったりすると、ディスクにとっては都合が悪いのです。
(ファイルシステム上のファイルを使うことを前提にすれば、出来なくはありません。非効率なことが多いですけれど。
HDD や flash SSD では block 単位の方が良いと思いますが、昨今実用化されつつある NVRAM であれば、
byte-addressable すなわち任意のサイズでの IO が出来るものがあるため、そのような制約は過去のものになる可能性はあります。)


> ・以前RDBMSのデータは直接ポインタは持たないとおっしゃっていたのですが、今回Recordへの参照データがノードとして存在しているとおっしゃられていました。これの違いがよくわからないので教えて頂きたいです。

内部的にはもちろん参照データを持っています。それは、インデクスのデータから record の実体の位置を指していたりするわけです。
もちろんデータ構造をどう設計するかに依存しますが、参照データなしでインデクス構造は作れないといっても過言ではありません。
SQL の世界(や、組込み DBMS のアプリケーションに見えるインターフェース) では、ポインタ(参照)を扱えません。
ユーザーにとって使えるポインタ型、参照型が(意図的に)用意されていないといった方が正確かも。




ハードウェアの進化によって、効率の良いソフトウェアのアーキテクチャはときどきガラリと変わります。
昨今だと、
 *  CPU の メニーコア化 (とにかく並列に動かさないと性能が出ない時代の到来)
 * メインメモリサイズの増大 (データベースがすっぽり収まるケースが増えてきた)
 * HDD から Flash memory へ (シーケンシャルアクセスとランダムアクセスの性能差が縮まる、flush request の有無)
 * 高速ネットワークの低価格化(Ethernet 10G とか)
 * GPGPU や FPGA の進化 (トランザクション処理にとっては今のところ影響は少ないが、分析系の処理には大きな影響がある)
 * NVRAM (3D Xpoint が去年発売にこぎつけましたが、それがメモリ階層の中で不可欠な役割を担うようになるかまだ五分五分と私は見ています)

が、大きな影響を与えていると思います。

トランザクション処理という視点で見ると、今の DBMS 研究の世界で見えているもの(私はかじっているだけですが。。)と、現実の DBMS 実装には大きな乖離があります。
今の主流の実装は、1990年代に最適だったものから継ぎ足しで進化してきているものが多いと思います。
商用の SQL をサポートするようなコードベースが大きい DBMS (Oracle とか MS SQL とか IBM DB2 とか) は、この変化についていくのが大変です。
それまで儲けたお金で莫大な投資をしなければ、ついていけません。
MySQL、PostgreSQL などは、どこまで付いていけるか、見物ですね。場合によっては新たに出てくる OSS に取って代わられる可能性もあります。
それでも、DBMS は最も「枯れている」ことを要求されるソフトウェアのひとつなので、一旦市民権を確立したソフトウェアの寿命は相対的に長いと思います。

===[/column]
