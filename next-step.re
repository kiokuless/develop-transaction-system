= DBMS を学ぶためのリファレンス設計 応用


「リファレンス設計 基本」に従ってプロトタイプを作り，動かしたりテストしたりして満足し，
次のステップに進みたいと思った方は，
楽しい並行実行制御やその他の改善を実装するための準備をしていきましょう．

本資料では，向かうべき方向について概要のみを述べます．
詳しくは，キーワードを頼りにご自分で調べてみてください．
場合によっては専門の教科書や学術論文を読まないといけないこともあるでしょう．

シングルスレッドで並行実行制御ナシ，マルチスレッドで並行実行制御アリ，
の間に，厳密には，シングルスレッドで並行実行制御アリ，というカテゴリが考えられます．
CPU コアはひとつしか使わないけれど，IO の間だけ別の処理をするとか，自分で
処理を切り替える，いわゆるユーザースレッドを使って並行処理を行うシステムです．
昔はまさにそうしていたと思いますが，CPU コアがたくさん使える時代において，
並行実行制御をするけれど，CPU コアはひとつしか使わない縛りをする意味があるとは思えませんので，
並行実行制御をするなら，CPU コアをたくさん使ってスケーラブルなシステムを作ることを目指してください．



== データ構造の排他処理

まず，データ構造に排他処理が必要になります．ここでまずやることがものす
ごく増え，難しくなります．

 * シングルスレッドでアクセスすることが前提のインデクス構造は動きません．
 * もちろんインデクスまるごと排他すれば動きますが，全然スケールしないですよね．
 * インデクス構造で細粒度の排他をする方法は色々と提案されていますが，
  枯れているものとして，intention lock があります．
 * 最近は，mutex-free なインデクス構造を使うことも珍しくなくなってきたと思いますが，
  GC の仕組みとセットになるなので，実装難易度は高めだと思います．
  (Java などの GC が前提の言語だとこのあたりは楽できます．速いかどうかは知りませんが．．)
  具体的な設計を挙げると，Bw-tree とか，Masstree などでしょうか．
 * ごくごく単純なプロトタイプレベルでよければ，insert も delete もなし，update と retrieve のみを前提に，
  インデクス構造もなし，ただの固定配列 (fixed array，key は array index) をインメモリ DB として
  並行実行制御を実装して動かしてみることはできます．


== 並行実行制御

次に並行実行制御を実装していきます．

まずは S2PL を実装してみましょう．
ロック機構を用意します．reader-writer lock で構いません．
Lock 機構ひとつとっても fairness (公平性)とか cancel 可能とか言い始めると奥が深い分野です．
Record 毎に mutex object を用意します．
ロックテーブルを用意するアーキテクチャもありますが，
簡単なのは，record 毎に mutex object を用意するアプローチだと思います．
Record を格納する構造体に確保しても良いですし，ポインタのみ保持して，
別途確保された mutex object を指しても良いです．

単純な S2PL では phantom read anomaly を防げませんので，それをなんとかします．
Range query と insert が衝突するように排他を設計すれば良いです．
通常は record を格納するページ単位で実現します．
Next key lock という手段もあります(MySQL が採用しています)．

実は S2PL には deadlock という問題があります．
例えば record A -> record B という順番で lock するトランザクションと
record B --> record A という順番で lock するトランザクションを同時に動かすと，
いとも簡単にお互いがお互いを待ち続けてしまう，いわゆる deadlock が発生してしまいます．
Deadlock は困るのでなんとかしたいと思った方は，Deadlock avoidance とか deadlock prevension という
キーワードで調べてみてください．

他の並行実行制御手法について調べて，探求しましょう．
キーワードとしては，OCC (Optimistic concurrency control)，MVCC (Multi-version concurency control)
などです．
既存の deadlock を解決する方法の多くは，starvation という別の問題を引き起こしますので，
それについても探求してみてください．


== WAL

WAL はまずシングル WAL のままで実装することを考えてみましょう．

マルチスレッドで実行している場合，複数のトランザクションが同時にログを書こうとするわけなので，
直列化のための排他が必要になります．
通常は，thread-safe な queue 構造を用意して，それを経由して WAL に書き込むことで直列化を実現します．

WAL がボトルネックになると思ったら，パラレル WAL にも挑戦してみてください．
並列に複数の WAL ファイルに書くとしたら，どうやって
トランザクションの依存関係を担保すれば良いでしょうか．．．これも奥深いテーマです．
現時点では，複数の論文を読んだり，分厚い教科書を読まないと理解できない知識かも知れません．．．

ハードウェアアーキテクチャの進化によっては，WAL という仕組みそのものが
効率などの面で過去のものになる可能性もあります．
あくまで WAL は atomicity と durability を実現するためのいち手段ということを忘れないでください．


== おわりに

駆け足で説明していまいましたが，これらひとつひとつが大きなテーマだと思います．
トランザクション処理だけでこれだけのことを考えなければならないのです．
OS ほどではないかも知れませんが，かなり入り組んだシステムであることが分かっていただけましたでしょうか．

ここではトランザクション処理に注目しましたが，
データを扱う処理として，データ分析というテーマが別にあります．
SQL はどちらかというと，データ分析のための言語と言っても良いでしょう．
大量のデータを複雑な条件で選択したり，変換したり，ソート，集約，結合，などなど
様々な処理を行えます．実装としては，トランザクションをサポートしている DBMS (MySQL や postgreSQL など) でも
出来ますが，大規模なデータに対して動かしたけれど，例えば Hadoop や Spark などがそれを担ってくれます．
それとは別に，特殊なデータベースとして，全文検索エンジンがあります．こちらも
特殊なインデクスを提供し，キーワードなどによる文書検索を担う DBMS と考えることが出来るでしょう．
トランザクションシステムとこれらのデータ分析等のシステムの統合や連携については，
様々な試みがなされています．
個人的な感想ですが，データ分析やその基盤を探求している方は，
トランザクション処理を探求している方々よりも人口が多い気がします．

新しい用途が生まれたり，ハードウェアアーキテクチャの進化に合わせて
DBMS の良いアーキテクチャも変わっていきます．
探究心を忘れずに，今後も楽しい DBMS 開発人生を過ごしてください．
