= DBMS を学ぶためのリファレンス設計 基本


これまで、トランザクションを処理を目的とした DBMS が備えているべき
機能や性質について説明してきました。
では、どんな機能があればトランザクション処理できると言えるでしょうか。
本章では、トランザクション処理ができるといえる最小限の機能セットについて考えます。
習うより慣れろの精神で、作ってみよう、という人はこれを読んで
実際に動くプログラムとしての DBMS を作ってみてください。



== 並行実行制御

並行実行制御は、今なおより良いものを求めて研究が行われている奥深いテーマですが、
必要最小限のトランザクション処理システムに必要か、と言われると、
なくても成立すると思いますので、ここでは涙を飲んでバッサリ削ろうと思います。
並行実行制御をせずに、きちんと動かす、すなわち serializable に実行するためにはどうするか。
そうです、本当に serial (直列)実行をすれば良いのです。
直列実行するスケジューラを trivial scheduler といいます。
また、データ構造の排他は大変＆設計と実装の難易度が上がりますので、思いきって
シングルスレッドで動かす DBMS を作ることにしましょう。

ということで皆さんはまずシングルスレッドで動くトランザクション処理システムを
作ることを目標にしてもらおうと思います。
Trivial scheduler には並行実行制御は不要なので、
インデクスと WAL 機能があれば最小限の DBMS ができることになります。



== インデクスとスキーマ

インデクスを実現するデータ構造について、Tree map と Hash table を紹介しました。
より単純な DBMS は、どちらかのみサポートしているでしょう。
どちらでも良いですが、迷ったら tree map をオススメしておきます。
Tree map なら range query が出来ますからね。
インデクスを使わずに record の配列をデータベースだ、と主張することも不可能ではありません。
Table full scan はできますからね。
ただ、お目当ての record に低コストでアクセスできる機能は必須としたいと思います。

メモリ上とディスク上のデータフォーマットを無理に共通化したくありませんし、
ページ単位で atomic に書いたりするのが面倒そうですし、何よりバッファキャッシュ管理をしたくない
(この本でも説明していません！！！）ので、
インメモリ DBMS を作ることにしましょう。
メモリに格納できない大きなデータベースは扱わないという割り切りをします。
これで、メモリ上でインデクスを実装すれば良くなりました。
シングルスレッド前提なので、排他制御も不要です。
あれ、多くのプログラミング言語ではほぼ標準ライブラリで
この要件を満たす tree map や hash table を用意しているようですよ。。
それらのライブラリを使えばインデクスが何故高速か、そのメカニズムを知らなくても
インデクスを実装できてしまいます。
私としては学びのために自分でインデクス構造を実装することも検討して欲しいのですが、
最小限、という意味ではサボって構いません。

DDL (data definition language) 等を用意すると手間なので、
設定ファイルを読み込む形で定義させるか、もっと簡単に作るために、
ハードコーディングしてしまいましょう。
動的なスキーマ変更もサポートしないこととします。

Record の仕様を決めましょう。
もちろん、たくさんの primitive 型を用意して、任意の column を組み合わせて record を定義できると便利ですが、
設計と実装を簡単にするために、サボりましょう。
巷の key-value store と呼ばれるものには、key 型も value 型もバイト列型しか選べないものもあるようです。
バイト列は表示するときに面倒なので、いっそ文字列に限定してしまいましょうか。
文字列も、ユニコードだのなんだのは面倒くさいので、ascii 文字だけに限定してしまいましょう。

リッチなスキーマを想定するのであれば、セカンダリインデクスは欲しくなりますが、
key-value store なら、プライマリインデクスだけあれば良いでしょう。
必要になったとしても、同じデータ構造を流用すれば良いので、セカンダリインデクスは比較的簡単に実装できると思います。


== Write-ahead Logging

インメモリ DBMS とはいっても、ACID property を満たすために永続化はしないといけません。
ログ先行書き込み (WAL) 機能は commit 条件を満たすために実装する必要があります。
ログファイルのフォーマットを決めましょう。
DBMS がどんなデータ操作をサポートするかを決めて、
そのオペレーションの redo log の仕様を決めます。
SQL と似たようなインターフェースを想定するのであれば、
update/insert/delete の三種類をサポートすることになります。
もっと簡単にしたいなら、put (upsert) のみサポートするのもありでしょう。
Upsert とは、その primary key を持つ record が存在していなければ insert、
存在していたら update する、という操作です。

Redo/undo log のどれを採用するかについて、
trivial scheduler を使う場合、トランザクションロジックによる明示的な abort 命令と
crash による abort 以外は abort しませんので、比較的簡単に実装できる redo log のみを使う設計をオススメします。
Crash する未来を除いて commit する運命が確定するまでデータベース本体に変更を反映するのを待つ
処理を入れれば undo log は不要です。
Redo log は 後述する write set から作れます。


== Read set と write set

DBMS 側のトランザクション実行エンジンはどのように振る舞えば良いでしょうか。
我々は non-deterministic DBMS を想定すると言いましたね。
実行エンジンは次にどんな命令が来るのか分からないので、トランザクションの状態管理をする必要があります。

同じ record に対する複数回のアクセスをうまく吸収するための仕組みとして read set と write set があります。
Read set はトランザクションの中で、過去に読んだことのある record の参照とその内容を保持しておきます。
Write set はトランザクションが書いた内容で、やはり record の参照とともに保持しておきます。
Trivial scheduler を採用するとき read set は不要です。なぜなら自分以外にトランザクションは
並行に実行されていないので、同じ record を何回読んでも自分が変更しない限り同じだからです。

Trivial scheduler を採用していても write set は必要です。
何故なら redo log のみ記録する設計にしているからです。
Redo log しか記録しない場合、永続化も含めて commit が確定するまでデータベース本体に変更を反映してはいけないです。
もし commit 前にデータベース本体に反映してしまい、その後トランザクションロジックから abort 命令が来たら
undo できなくて詰みます。Commit が確定するということは undo する必要がなくなるということです。
トランザクション実行中はデータベース本体と write set は別々に管理して、
トランザクションロジックからはあたかもそれまでの変更がデータベース本体に反映されているかのように
振る舞います。
すなわち、write set に存在する record の read 要求に対しては write set に保持されている内容を返すということです。
別の見方をすれば write set はキャッシュデータとして振る舞います。

Write set はトランザクションによるデータベース変更への変更データそのものなので、
write set から redo log が作れます。自分で決めたフォーマットに従って変換するだけです。



== Checkpointing

Checkpointing は出来るだけ簡単なものにしたいので、
トランザクションが動いていないときのみ、いやいやもっと極端に起動時のみにやることにしましょう。
起動時には、前回の checkpointing 時のデータベースファイルをメモリに読み出し、
WAL ファイルの中身を redo してメモリ上に正しいデータベース構造を構築し、
そのイメージをディスクに書き出し、WAL ファイルを空にしてからトランザクションを受けつけます。
これなら、排他処理不要のデータベースファイルの dump/load 機能を用意するだけで済み、
ちまちまと細粒度に checkpointing するコードを書くのを避けられます。
その代わり、起動時に皺寄せがきますが、諦めましょう。
また、dump 操作は atomic にファイルを書くことを忘れないようにしましょう。


== トランザクションとワークロード

Read/insert/update/delete (もしくは get/put)、そして commit/abort を実行する API を用意して、
簡単な動作確認をするためのトランザクションを実装してください。
トランザクションロジックが呼び出すデータベース操作 API はライブラリとして実装しましょう。
ネットワークなどを介した専用プロトコルを用意するより簡単です。
それを組み込み DBMS というのでしたね。
トランザクションやそれを呼び出すワークロードも同じプログラミング言語で書いて DBMS 実装に
組み込んでしまいましょう。
とはいえ、たとえコンパイルで同一バイナリになるとしても、
インターフェースをきちんと定義して境界を意識して設計実装してください。
DBMS が起動し、初期化が終わってトランザクションを受けつけられる状態になったら、
トランザクションを有限個または無限個実行するような
コード(ワークロード実装)を用意しておいて動かしてください。

Crash test がしたい場合は、外部から強制的に DBMS が動いているホストを落とすので、
トランザクションを無限に実行し続けるようにしておく必要がありますね。
性能測定がしたい場合は、時間を測ったり実行できたトランザクションの個数を数えたり
するコードもアプリケーションとして一緒に書いてしまいましょう。


== 作って動かしてみる


以上で、大体のアーキテクチャは固まってきました。
細かいところは自分で考えてみてください。また、ご自分の興味に従って設計を変更しても大丈夫です。
どんな設計をすればどんな制約が出てくるかを考えるのは大切なことです。
考えながら設計しましょう。ただし、まずは出来るだけ簡単なものを作ることが大事です。
そして、動く状態を保ちながら機能を追加していくこともまた大事です。
どこから手をつけるべきかも含めて考えましょう。



== テスト

作ったプログラムが正しく動いていることを確認するにはテストをすることが欠かせません。
正常系として、データ操作をしたらそれが反映されているか、などの基本動作についてテストします。
プロダクションで動かすことを考えていくならエラー処理(そして異常系テスト)がとても重要ですが、
学習用のプログラムなので、ある程度は目をつぶりましょう。
しかし、異常系の中で DBMS としてひとつだけ絶対に押さえておかなければならないテストがあります。
それが crash test です。
トランザクション実行中にマシンの電源を落として、crash recovery できることを確認してください。
Virtual Machine を使って仮想的に電源を落とすのが良いでしょう。
Commit の返事をしたのに反映されていないことがないかどうか、
中途半端な状態になっていないか、データとして壊れていないかどうかを確認してください。



====[column] テストについて

コードを書いたり修正したとき、とりあえず動作確認をする行為は、スモークテストというそうですが、
それはそれでとても大事なテストです。
一方、私がここで話題にしたいものは、リグレッションテストと呼ばれています。
リグレッションテストとは、コード修正をしたことで、それまで期待通りに動いていたはずの機能が壊れたとき、
それに出来るだけ早く気付くためのテストです。
ですから、

 1. コードを変更したときにすぐに実行してパスするかどうかを確認できること
 2. CI などで自動化できること(テストの準備や実行をするスクリプト等の用意、テスト結果もコマンドの返り値などで判別できるようになっていること)

が必要になります。
今回、CI で動かす必要が必ずしもあるかは分かりませんが、
たとえば make utest などと実行したらすぐにテストが走るようにしておくことが重要です。

私は、C++ でプログラムを書く場合、同僚の作ってくれた簡易なヘルパ関数を使ってテストを作り、
それを make utest で動かせるようにしています。

 * https://github.com/herumi/cybozulib/blob/master/include/cybozu/test.hpp

これを使ってもいいですが、原則としては、終了コードでパスしたかどうかを判別できるようなテストプログラムを
テストしたい項目毎に書けば良いと思います。
もう少し複雑なテストをしたい場合は、環境や入力データの作成、テスト実行、
結果のチェックなどをする専用のスクリプトを書いたりします。
これもコマンド一発で動かせて、成功失敗を返り値などでチェックできるようにしておけば CI で動かせます。

実運用で使う、バグを踏むとものすごく困ったことになる、
メンテナンスを少なくとも数年続ける必要があるようなプログラムと違って、
今回のような学習用、プロトタイピング的なプログラムを作る場合に、このようなテストにたくさん時間をかけたくないでしょう。
ただ、何回も実行するのが面倒くさいと人間はサボるようになりますから、
何回も実行する必要があるテストは自動化しておきましょう。
Crash recovery は事ある度にテストして欲しいです。また、
データ構造とアルゴリズムのコードは、比較的テストしやすい一方で
複雑であるためバグを入れてしまいやすいです。
よって、積極的にテストコードを書きましょう。
ファイル操作やネットワーク通信など外部とのやりとりが絡むコードをテストするのは
相対的に面倒くさいです。部品毎のテストが無理そうなら、多少大きな単位になってしまっても、
テストしやすい粒度でテストしてください。

目安として、自分が複雑だと感じるコードや機能については、まず間違いなくテストが必要です。
色々な状態、入力に対して動くかなあ、と不安になったらテストの書き時です。
経験則として、そのようなコードは大抵の場合バグっています。もしテストを書かなくても大丈夫だと安心していた
コードがバグっていたことが判明したら、あなたの安心を感じるセンサーを修正する必要があります。
大前提としてバグをなくすことはできませんから、バグが入りにくい設計、実装を心がけることが重要なのは
いうまでもありません。


====[/column]
