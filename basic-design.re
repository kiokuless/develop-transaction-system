= DBMS を学ぶためのリファレンス設計 基本


並行実行制御は，今なおより良いものを求めて研究が行われている奥深いテーマですが，
必要最小限のトランザクション処理システムに必要か，と言われると，
なくても成立すると思いますので，ここでは涙を飲んでバッサリ削ろうと思います．

並行実行制御をせずに，きちんと動かす，すなわち serializable に実行するためにはどうするか．
そうです，本当に serial (直列)実行をすれば良いのです．

その他，データ構造の排他は大変＆設計と実装の難易度が上がりますので，思いきって
シングルスレッドで動かす DBMS を作ることにしましょう．

ということで皆さんはまずシングルスレッドで動くトランザクション処理システムを
作ることを目標にしてもらおうと思います．
ということは，インデクス構造と WAL があれば最低限の DBMS ができることになります．

インデクス構造について，Tree か Hash table かですが，迷ったら tree にしましょう．
なんたって Tree なら range query が出来ますからね．

メモリ上とディスク上のデータフォーマットを無理に合わせる必要もありませんし，
諸々ページ単位で atomic に書いたりするのが面倒そうなので，
インメモリ DBMS を作ることにしましょう．メモリより大きなデータは扱わないという割り切りをします．
これで，メモリ上で tree 構造を実装すれば良くなりました．

Record の仕様を決めましょう．
もちろん，たくさんの primitive 型を用意して，任意の column を組み合わせて record を定義できるのが望ましいですが，
実装を簡単にするために，サボりましょう．
とりあえず，文字列と整数，くらいでいいのではないでしょうか．

DDL (data definition language) 等を用意すると手間なので，
設定ファイル(もしくはハードコーディング)で設定させるようにしましょう．
楽をするためです．動的なスキーマ変更もサポートしないこととします．

インメモリ DBMS とはいっても，永続化はしないといけません．
WAL ファイルは commit 条件を満たすためにきちんと書かないといけません．
フォーマットを決めましょう．どんなオペレーションをサポートするかを決めて，
そのオペレーションの redo log の仕様を決めます．
undo log は使わないことにしましょう．インメモリ DBMS なので，
commit することが確定するまでインメモリの DB データに変更を反映するのを待てば undo log は不要になります．

Checkpointing は出来るだけ簡単なものにしたいので，
トランザクションが動いていない時間帯である，正常終了時と起動時のみにやることにしましょう．
起動時には，前回の DB ファイルをメモリに読み出し，
WAL ファイルの中身を redo してメモリ上に正しい DB を構築し，
そのイメージをディスクに書き出し，WAL ファイルを空にしてからトランザクションを受けつけます．
正常終了時には，トランザクションの受付を停止し，メモリ上の正しい DB をディスクに
書き出して WAL ファイルを空にしてから終了します．
これなら，dump/load 機能を用意するだけで済み，
ちまちまと細粒度で checkpointing するコードを書くのを避けられます．
その代わり，起動時と正常終了時に皺寄せがきますが，我慢しましょう．

トランザクションを実装するための API はライブラリとして実装しましょう．
専用プロトコルを用意するより簡単です．必要なら後で足せますし．．

セカンダリインデクスは欲しいですね．同じ構造で違うデータを扱うだけなので，
コードとしては少ししか増えないと思いますが．．．時間が足りない場合は省略しても構いません．

大体のアーキテクチャは固まってきましたね．．．
では作って動かしてみましょう！

テストしましょう．
正常系として，insert/update/delete したらそれが反映されているか，などの基本動作について test します．
プロダクションで動かすことを考えていくならエラー処理(そして異常系テスト)がとても重要ですが，
学習用のプログラムなので，ある程度は目をつぶりましょう．．
しかし，異常系の中で DBMS としてひとつだけ絶対に押さえておかなければならない test があります．
それが crash test です．
トランザクション実行中に電源を落として，crash recovery できることを確認してください．
(Virtual Machine を使って仮想的に電源を落とすのが良いでしょう．)
commit の返事をしたのに反映されていないことがないかどうか，
中途半端な DB 状態になっていないか，データとして壊れていないかどうかを確認してください．



===[column] テストについて

コードを書いたり修正したとき、とりあえず動作確認をする行為は、スモークテストというそうですが、それはそれでとても大事なテストです。
私がここで言っているテストは、主にリグレッションテストと呼んでいるものです。
あるコード修正をして、それまで期待通りに動いていたはずの機能が壊れたとき、それに出来るだけ早く気付くためのテストです。

ですから、
(1) コードを変更したときにすぐに実行してパスするかどうかを確認できること
(2) CI などで自動化できること(テストの準備や実行をするスクリプト等の用意、テスト結果もコマンドの返り値などで判別できるようになっていること)
が必要になります。
今回、CI で動かす必要が必ずしもあるかは分かりませんが、
たとえば make utest とか実行したらすぐにテストが走るようにしておくことが重要です。

私は、C++ の場合、同僚の作ってくれた簡易なヘルパ関数を使ってテストを作り、それを make utest で動かせるようになっています。
https://github.com/herumi/cybozulib/blob/master/include/cybozu/test.hpp
これを使ってもいいですが、原則としては、終了コードでパスしたかどうかを判別できるようなテストプログラムをテストしたい項目毎に書けば良いと思います。
もう少し複雑なテストをしたい場合は、環境や入力データの作成、テスト実行、結果のチェックなどをする専用のスクリプトを書いたりしています。
(そのようにコマンド一発で動いて、成功失敗を返り値などでチェックできるようにしておけば CI で動かせますから。)

ただ、プロダクションで使うような、バグったらものすごく困ってしまう、メンテナンスを少なくとも数年続ける必要があるようなプログラムと違って、
今回のような学習用、プロトタイピング的なプログラムを作る場合に、このようなテストにたくさん時間をかけたくないでしょう。
ただ、何回も実行するのが面倒くさいと人間はサボるようになりますから、何回も実行する必要があるテストは自動化しておきましょう。

Crash recovery は何回でもテストして欲しいので挙げましたし、
B+tree などもそれなりに複雑なロジックで、色々な状態、入力に対して動くことを確認したくなるはずですから、
テストコード書きましょう、となるわけです。

===[/column]
